"""
This type stub file was generated by pyright.
"""

import io
import os
import six
from .kaggle_api import KaggleApi

class DirectoryArchive:
    def __init__(self, fullpath, format) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    


class ResumableUploadContext:
    def __init__(self, no_resume=...) -> None:
        ...
    
    def __enter__(self): # -> Self | None:
        ...
    
    def __exit__(self, exc_type, exc_value, exc_traceback): # -> None:
        ...
    
    def get_upload_info_file_path(self, path): # -> str:
        ...
    
    def new_resumable_file_upload(self, path, start_blob_upload_request): # -> ResumableFileUpload:
        ...
    


class ResumableFileUpload:
    RESUMABLE_UPLOAD_EXPIRY_SECONDS = ...
    def __init__(self, path, start_blob_upload_request, context) -> None:
        ...
    
    def get_token(self): # -> None:
        ...
    
    def load(self): # -> None:
        ...
    
    def upload_initiated(self, start_blob_upload_response): # -> None:
        ...
    
    def upload_completed(self): # -> None:
        ...
    
    def cleanup(self): # -> None:
        ...
    
    def to_dict(self): # -> dict[str, Any]:
        ...
    
    def from_dict(other, context): # -> ResumableFileUpload:
        ...
    
    def to_str(self): # -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class KaggleApi(KaggleApi):
    __version__ = ...
    CONFIG_NAME_PROXY = ...
    CONFIG_NAME_COMPETITION = ...
    CONFIG_NAME_PATH = ...
    CONFIG_NAME_USER = ...
    CONFIG_NAME_KEY = ...
    CONFIG_NAME_SSL_CA_CERT = ...
    HEADER_API_VERSION = ...
    DATASET_METADATA_FILE = ...
    OLD_DATASET_METADATA_FILE = ...
    KERNEL_METADATA_FILE = ...
    MODEL_METADATA_FILE = ...
    MODEL_INSTANCE_METADATA_FILE = ...
    MAX_NUM_INBOX_FILES_TO_UPLOAD = ...
    MAX_UPLOAD_RESUME_ATTEMPTS = ...
    config_dir = ...
    if not config_dir:
        config_dir = ...
    if not os.path.exists(config_dir):
        ...
    config_file = ...
    config = ...
    config_values = ...
    already_printed_version_warning = ...
    valid_push_kernel_types = ...
    valid_push_language_types = ...
    valid_push_pinning_types = ...
    valid_list_languages = ...
    valid_list_kernel_types = ...
    valid_list_output_types = ...
    valid_list_sort_by = ...
    valid_competition_groups = ...
    valid_competition_categories = ...
    valid_competition_sort_by = ...
    valid_dataset_file_types = ...
    valid_dataset_license_names = ...
    valid_dataset_sort_bys = ...
    valid_model_sort_bys = ...
    command_prefixes_allowing_anonymous_access = ...
    if six.PY2:
        ...
    def with_retry(self, func, max_retries=..., initial_delay_millis=..., retry_multiplier=..., randomness_factor=...): # -> Callable[..., Any | None]:
        ...
    
    def authenticate(self): # -> None:
        """authenticate the user with the Kaggle API. This method will generate
           a configuration, first checking the environment for credential
           variables, and falling back to looking for the .kaggle/kaggle.json
           configuration file.
        """
        ...
    
    def read_config_environment(self, config_data=..., quiet=...): # -> dict[Any, Any]:
        """read_config_environment is the second effort to get a username
           and key to authenticate to the Kaggle API. The environment keys
           are equivalent to the kaggle.json file, but with "KAGGLE_" prefix
           to define a unique namespace.

           Parameters
           ==========
           config_data: a partially loaded configuration dictionary (optional)
           quiet: suppress verbose print of output (default is False)
        """
        ...
    
    def read_config_file(self, config_data=..., quiet=...): # -> Any | dict[Any, Any]:
        """read_config_file is the first effort to get a username
           and key to authenticate to the Kaggle API. Since we can get the
           username and password from the environment, it's not required.

           Parameters
           ==========
           config_data: the Configuration object to save a username and
                        password, if defined
           quiet: suppress verbose print of output (default is False)
        """
        ...
    
    def set_config_value(self, name, value, quiet=...): # -> None:
        """a client helper function to set a configuration value, meaning
           reading in the configuration file (if it exists), saving a new
           config value, and then writing back

           Parameters
           ==========
           name: the name of the value to set (key in dictionary)
           value: the value to set at the key
           quiet: disable verbose output if True (default is False)
        """
        ...
    
    def unset_config_value(self, name, quiet=...): # -> None:
        """unset a configuration value
            Parameters
           ==========
           name: the name of the value to unset (remove key in dictionary)
           quiet: disable verbose output if True (default is False)
        """
        ...
    
    def get_config_value(self, name): # -> None:
        """ return a config value (with key name) if it's in the config_values,
            otherwise return None

            Parameters
            ==========
            name: the config value key to get

        """
        ...
    
    def get_default_download_dir(self, *subdirs): # -> str:
        """ Get the download path for a file. If not defined, return default
            from config.

            Parameters
            ==========
            subdirs: a single (or list of) subfolders under the basepath
        """
        ...
    
    def print_config_value(self, name, prefix=..., separator=...): # -> None:
        """print a single configuration value, based on a prefix and separator

           Parameters
           ==========
           name: the key of the config valur in self.config_values to print
           prefix: the prefix to print
           separator: the separator to use (default is : )
        """
        ...
    
    def print_config_values(self, prefix=...): # -> None:
        """a wrapper to print_config_value to print all configuration values
            Parameters
           ==========
           prefix: the character prefix to put before the printed config value
                   defaults to "- "
        """
        ...
    
    def competitions_list(self, group=..., category=..., sort_by=..., page=..., search=...): # -> list[Competition]:
        """ make call to list competitions, format the response, and return
            a list of Competition instances

            Parameters
            ==========

            page: the page to return (default is 1)
            search: a search term to use (default is empty string)
            sort_by: how to sort the result, see valid_competition_sort_by for options
            category: category to filter result to
            group: group to filter result to
        """
        ...
    
    def competitions_list_cli(self, group=..., category=..., sort_by=..., page=..., search=..., csv_display=...): # -> None:
        """ a wrapper for competitions_list for the client.

            Parameters
            ==========
            group: group to filter result to
            category: category to filter result to
            sort_by: how to sort the result, see valid_sort_by for options
            page: the page to return (default is 1)
            search: a search term to use (default is empty string)
            csv_display: if True, print comma separated values
        """
        ...
    
    def competition_submit(self, file_name, message, competition, quiet=...): # -> SubmitResult | Literal['Could not submit to competition']:
        """ submit a competition!

            Parameters
            ==========
            file_name: the competition metadata file
            message: the submission description
            competition: the competition name
            quiet: suppress verbose output (default is False)
        """
        ...
    
    def competition_submit_cli(self, file_name, message, competition, competition_opt=..., quiet=...): # -> SubmitResult | Literal['Could not submit to competition'] | None:
        """ submit a competition using the client. Arguments are same as for
            competition_submit, except for extra arguments provided here.
             Parameters
            ==========
            competition_opt: an alternative competition option provided by cli
        """
        ...
    
    def competition_submissions(self, competition, page_token=..., page_size=...): # -> list[Submission]:
        """ get the list of Submission for a particular competition

            Parameters
            ==========
            competition: the name of the competition
            page_token: token for pagination
            page_size: the number of items per page
        """
        ...
    
    def competition_submissions_cli(self, competition=..., competition_opt=..., csv_display=..., page_token=..., page_size=..., quiet=...): # -> None:
        """ wrapper to competition_submission, will return either json or csv
            to the user. Additional parameters are listed below, see
            competition_submissions for rest.

            Parameters
            ==========
            competition: the name of the competition. If None, look to config
            competition_opt: an alternative competition option provided by cli
            csv_display: if True, print comma separated values
            page_token: token for pagination
            page_size: the number of items per page
            quiet: suppress verbose output (default is False)
        """
        ...
    
    def competition_list_files(self, competition, page_token=..., page_size=...): # -> FileList:
        """ list files for competition
             Parameters
            ==========
            competition: the name of the competition
            page_token: the page token for pagination
            page_size: the number of items per page
        """
        ...
    
    def competition_list_files_cli(self, competition, competition_opt=..., csv_display=..., page_token=..., page_size=..., quiet=...): # -> None:
        """ List files for a competition, if it exists

            Parameters
            ==========
            competition: the name of the competition. If None, look to config
            competition_opt: an alternative competition option provided by cli
            csv_display: if True, print comma separated values
            page_token: the page token for pagination
            page_size: the number of items per page
            quiet: suppress verbose output (default is False)
        """
        ...
    
    def competition_download_file(self, competition, file_name, path=..., force=..., quiet=...): # -> None:
        """ download a competition file to a designated location, or use
            a default location

            Parameters
            =========
            competition: the name of the competition
            file_name: the configuration file name
            path: a path to download the file to
            force: force the download if the file already exists (default False)
            quiet: suppress verbose output (default is False)
        """
        ...
    
    def competition_download_files(self, competition, path=..., force=..., quiet=...): # -> None:
        """ downloads all competition files.

            Parameters
            =========
            competition: the name of the competition
            path: a path to download the file to
            force: force the download if the file already exists (default False)
            quiet: suppress verbose output (default is True)
        """
        ...
    
    def competition_download_cli(self, competition, competition_opt=..., file_name=..., path=..., force=..., quiet=...): # -> None:
        """ a wrapper to competition_download_files, but first will parse input
            from API client. Additional parameters are listed here, see
            competition_download for remaining.

            Parameters
            =========
            competition: the name of the competition
            competition_opt: an alternative competition option provided by cli
            file_name: the configuration file name
            path: a path to download the file to
            force: force the download if the file already exists (default False)
            quiet: suppress verbose output (default is False)
        """
        ...
    
    def competition_leaderboard_download(self, competition, path, quiet=...): # -> None:
        """ Download competition leaderboards

            Parameters
            =========
            competition: the name of the competition
            path: a path to download the file to
            quiet: suppress verbose output (default is True)
        """
        ...
    
    def competition_leaderboard_view(self, competition): # -> list[LeaderboardEntry]:
        """ view a leaderboard based on a competition name

            Parameters
            ==========
            competition: the competition name to view leadboard for
        """
        ...
    
    def competition_leaderboard_cli(self, competition, competition_opt=..., path=..., view=..., download=..., csv_display=..., quiet=...): # -> None:
        """ a wrapper for competition_leaderbord_view that will print the
            results as a table or comma separated values

            Parameters
            ==========
            competition: the competition name to view leadboard for
            competition_opt: an alternative competition option provided by cli
            path: a path to download to, if download is True
            view: if True, show the results in the terminal as csv or table
            download: if True, download the entire leaderboard
            csv_display: if True, print comma separated values instead of table
            quiet: suppress verbose output (default is False)
        """
        ...
    
    def dataset_list(self, sort_by=..., size=..., file_type=..., license_name=..., tag_ids=..., search=..., user=..., mine=..., page=..., max_size=..., min_size=...): # -> list[Dataset]:
        """ return a list of datasets!

            Parameters
            ==========
            sort_by: how to sort the result, see valid_dataset_sort_bys for options
            size: Deprecated
            file_type: the format, see valid_dataset_file_types for string options
            license_name: string descriptor for license, see valid_dataset_license_names
            tag_ids: tag identifiers to filter the search
            search: a search term to use (default is empty string)
            user: username to filter the search to
            mine: boolean if True, group is changed to "my" to return personal
            page: the page to return (default is 1)
            max_size: the maximum size of the dataset to return (bytes)
            min_size: the minimum size of the dataset to return (bytes)
        """
        ...
    
    def dataset_list_cli(self, sort_by=..., size=..., file_type=..., license_name=..., tag_ids=..., search=..., user=..., mine=..., page=..., csv_display=..., max_size=..., min_size=...): # -> None:
        """ a wrapper to dataset_list for the client. Additional parameters
            are described here, see dataset_list for others.

            Parameters
            ==========
            sort_by: how to sort the result, see valid_dataset_sort_bys for options
            size: DEPRECATED
            file_type: the format, see valid_dataset_file_types for string options
            license_name: string descriptor for license, see valid_dataset_license_names
            tag_ids: tag identifiers to filter the search
            search: a search term to use (default is empty string)
            user: username to filter the search to
            mine: boolean if True, group is changed to "my" to return personal
            page: the page to return (default is 1)
            csv_display: if True, print comma separated values instead of table
            max_size: the maximum size of the dataset to return (bytes)
            min_size: the minimum size of the dataset to return (bytes)
        """
        ...
    
    def dataset_metadata_prep(self, dataset, path): # -> tuple[Any | None, Any, str | Any]:
        ...
    
    def dataset_metadata_update(self, dataset, path): # -> None:
        ...
    
    def dataset_metadata(self, dataset, path): # -> str:
        ...
    
    def dataset_metadata_cli(self, dataset, path, update, dataset_opt=...): # -> None:
        ...
    
    def dataset_list_files(self, dataset, page_token=..., page_size=...): # -> ListFilesResult:
        """ list files for a dataset
             Parameters
            ==========
            dataset: the string identified of the dataset
                     should be in format [owner]/[dataset-name]
            page_token: the page token for pagination
            page_size: the number of items per page
        """
        ...
    
    def dataset_list_files_cli(self, dataset, dataset_opt=..., csv_display=..., page_token=..., page_size=...): # -> None:
        """ a wrapper to dataset_list_files for the client
            (list files for a dataset)
             Parameters
            ==========
            dataset: the string identified of the dataset
                     should be in format [owner]/[dataset-name]
            dataset_opt: an alternative option to providing a dataset
            csv_display: if True, print comma separated values instead of table
            page_token: the page token for pagination
            page_size: the number of items per page
        """
        ...
    
    def dataset_status(self, dataset): # -> dict[Any, Any]:
        """ call to get the status of a dataset from the API
             Parameters
            ==========
            dataset: the string identified of the dataset
                     should be in format [owner]/[dataset-name]
        """
        ...
    
    def dataset_status_cli(self, dataset, dataset_opt=...): # -> dict[Any, Any]:
        """ wrapper for client for dataset_status, with additional
            dataset_opt to get the status of a dataset from the API
             Parameters
            ==========
            dataset_opt: an alternative to dataset
        """
        ...
    
    def dataset_download_file(self, dataset, file_name, path=..., force=..., quiet=..., licenses=...): # -> bool:
        """ download a single file for a dataset

            Parameters
            ==========
            dataset: the string identified of the dataset
                     should be in format [owner]/[dataset-name]
            file_name: the dataset configuration file
            path: if defined, download to this location
            force: force the download if the file already exists (default False)
            quiet: suppress verbose output (default is True)
            licenses: a list of license names, e.g. ['CC0-1.0']
        """
        ...
    
    def dataset_download_files(self, dataset, path=..., force=..., quiet=..., unzip=..., licenses=...): # -> None:
        """ download all files for a dataset

            Parameters
            ==========
            dataset: the string identified of the dataset
                     should be in format [owner]/[dataset-name]
            path: the path to download the dataset to
            force: force the download if the file already exists (default False)
            quiet: suppress verbose output (default is True)
            unzip: if True, unzip files upon download (default is False)
            licenses: a list of license names, e.g. ['CC0-1.0']
        """
        ...
    
    def dataset_download_cli(self, dataset, dataset_opt=..., file_name=..., path=..., unzip=..., force=..., quiet=...): # -> None:
        """ client wrapper for dataset_download_files and download dataset file,
            either for a specific file (when file_name is provided),
            or all files for a dataset (plural)

            Parameters
            ==========
            dataset: the string identified of the dataset
                     should be in format [owner]/[dataset-name]
            dataset_opt: an alternative option to providing a dataset
            file_name: the dataset configuration file
            path: the path to download the dataset to
            force: force the download if the file already exists (default False)
            quiet: suppress verbose output (default is False)
            unzip: if True, unzip files upon download (default is False)
        """
        ...
    
    def dataset_create_version(self, folder, version_notes, quiet=..., convert_to_csv=..., delete_old_versions=..., dir_mode=...): # -> DatasetNewVersionResponse:
        """ create a version of a dataset

            Parameters
            ==========
            folder: the folder with the dataset configuration / data files
            version_notes: notes to add for the version
            quiet: suppress verbose output (default is False)
            convert_to_csv: on upload, if data should be converted to csv
            delete_old_versions: if True, do that (default False)
            dir_mode: What to do with directories: "skip" - ignore; "zip" - compress and upload
        """
        ...
    
    def dataset_create_version_cli(self, folder, version_notes, quiet=..., convert_to_csv=..., delete_old_versions=..., dir_mode=...): # -> None:
        """ client wrapper for creating a version of a dataset
             Parameters
            ==========
            folder: the folder with the dataset configuration / data files
            version_notes: notes to add for the version
            quiet: suppress verbose output (default is False)
            convert_to_csv: on upload, if data should be converted to csv
            delete_old_versions: if True, do that (default False)
            dir_mode: What to do with directories: "skip" - ignore; "zip" - compress and upload
        """
        ...
    
    def dataset_initialize(self, folder): # -> str:
        """ initialize a folder with a a dataset configuration (metadata) file

            Parameters
            ==========
            folder: the folder to initialize the metadata file in
        """
        ...
    
    def dataset_initialize_cli(self, folder=...): # -> None:
        ...
    
    def dataset_create_new(self, folder, public=..., quiet=..., convert_to_csv=..., dir_mode=...): # -> DatasetNewResponse:
        """ create a new dataset, meaning the same as creating a version but
            with extra metadata like license and user/owner.
             Parameters
            ==========
            folder: the folder to get the metadata file from
            public: should the dataset be public?
            quiet: suppress verbose output (default is False)
            convert_to_csv: if True, convert data to comma separated value
            dir_mode: What to do with directories: "skip" - ignore; "zip" - compress and upload
        """
        ...
    
    def dataset_create_new_cli(self, folder=..., public=..., quiet=..., convert_to_csv=..., dir_mode=...): # -> None:
        """ client wrapper for creating a new dataset
             Parameters
            ==========
            folder: the folder to get the metadata file from
            public: should the dataset be public?
            quiet: suppress verbose output (default is False)
            convert_to_csv: if True, convert data to comma separated value
            dir_mode: What to do with directories: "skip" - ignore; "zip" - compress and upload
        """
        ...
    
    def download_file(self, response, outfile, quiet=..., resume=..., chunk_size=...): # -> None:
        """ download a file to an output file based on a chunk size

            Parameters
            ==========
            response: the response to download
            outfile: the output file to download to
            quiet: suppress verbose output (default is True)
            chunk_size: the size of the chunk to stream
            resume: whether to resume an existing download
        """
        ...
    
    def kernels_list(self, page=..., page_size=..., dataset=..., competition=..., parent_kernel=..., search=..., mine=..., user=..., language=..., kernel_type=..., output_type=..., sort_by=...): # -> list[Kernel]:
        """ list kernels based on a set of search criteria

            Parameters
            ==========
            page: the page of results to return (default is 1)
            page_size: results per page (default is 20)
            dataset: if defined, filter to this dataset (default None)
            competition: if defined, filter to this competition (default None)
            parent_kernel: if defined, filter to those with specified parent
            search: a custom search string to pass to the list query
            mine: if true, group is specified as "my" to return personal kernels
            user: filter results to a specific user
            language: the programming language of the kernel
            kernel_type: the type of kernel, one of valid_list_kernel_types (str)
            output_type: the output type, one of valid_list_output_types (str)
            sort_by: if defined, sort results by this string (valid_list_sort_by)
        """
        ...
    
    def kernels_list_cli(self, mine=..., page=..., page_size=..., search=..., csv_display=..., parent=..., competition=..., dataset=..., user=..., language=..., kernel_type=..., output_type=..., sort_by=...): # -> None:
        """ client wrapper for kernels_list, see this function for arguments.
            Additional arguments are provided here.
             Parameters
            ==========
            csv_display: if True, print comma separated values instead of table
        """
        ...
    
    def kernels_list_files(self, kernel, page_token=..., page_size=...): # -> FileList:
        """ list files for a kernel
            Parameters
            ==========
            kernel: the string identifier of the kernel
                     should be in format [owner]/[kernel-name]
            page_token: the page token for pagination
            page_size: the number of items per page
        """
        ...
    
    def kernels_list_files_cli(self, kernel, kernel_opt=..., csv_display=..., page_token=..., page_size=...): # -> None:
        """ a wrapper to kernel_list_files for the client
            (list files for a kernel)
             Parameters
            ==========
            kernel: the string identifier of the kernel
                     should be in format [owner]/[kernel-name]
            kernel_opt: an alternative option to providing a kernel
            csv_display: if True, print comma separated values instead of table
            page_token: the page token for pagination
            page_size: the number of items per page
        """
        ...
    
    def kernels_initialize(self, folder): # -> str:
        """ create a new kernel in a specified folder from template, including
            json metadata that grabs values from the configuration.
             Parameters
            ==========
            folder: the path of the folder
        """
        ...
    
    def kernels_initialize_cli(self, folder=...): # -> None:
        """ client wrapper for kernels_initialize, takes same arguments but
            sets default folder to be None. If None, defaults to present
            working directory.
             Parameters
            ==========
            folder: the path of the folder (None defaults to ${PWD})
        """
        ...
    
    def kernels_push(self, folder): # -> KernelPushResponse:
        """ read the metadata file and kernel files from a notebook, validate
            both, and use Kernel API to push to Kaggle if all is valid.
             Parameters
            ==========
            folder: the path of the folder
        """
        ...
    
    def kernels_push_cli(self, folder): # -> None:
        """ client wrapper for kernels_push, with same arguments.
        """
        ...
    
    def kernels_pull(self, kernel, path, metadata=..., quiet=...):
        """ pull a kernel, including a metadata file (if metadata is True)
            and associated files to a specified path.
             Parameters
            ==========
            kernel: the kernel to pull
            path: the path to pull files to on the filesystem
            metadata: if True, also pull metadata
            quiet: suppress verbosity (default is True)
        """
        ...
    
    def kernels_pull_cli(self, kernel, kernel_opt=..., path=..., metadata=...): # -> None:
        """ client wrapper for kernels_pull
        """
        ...
    
    def kernels_output(self, kernel, path, force=..., quiet=...): # -> list[Any]:
        """ retrieve output for a specified kernel
             Parameters
            ==========
            kernel: the kernel to output
            path: the path to pull files to on the filesystem
            force: if output already exists, force overwrite (default False)
            quiet: suppress verbosity (default is True)
        """
        ...
    
    def kernels_output_cli(self, kernel, kernel_opt=..., path=..., force=..., quiet=...): # -> None:
        """ client wrapper for kernels_output, with same arguments. Extra
            arguments are described below, and see kernels_output for others.
             Parameters
            ==========
            kernel_opt: option from client instead of kernel, if not defined
        """
        ...
    
    def kernels_status(self, kernel): # -> dict[Any, Any]:
        """ call to the api to get the status of a kernel.
             Parameters
            ==========
            kernel: the kernel to get the status for
        """
        ...
    
    def kernels_status_cli(self, kernel, kernel_opt=...): # -> None:
        """ client wrapper for kernel_status
             Parameters
            ==========
            kernel_opt: additional option from the client, if kernel not defined
        """
        ...
    
    def model_get(self, model): # -> dict[Any, Any]:
        """ call to get a model from the API
             Parameters
            ==========
            model: the string identified of the model
                     should be in format [owner]/[model-name]
        """
        ...
    
    def model_get_cli(self, model, folder=...): # -> None:
        """ wrapper for client for model_get, with additional
            model_opt to get a model from the API
             Parameters
            ==========
            model: the string identified of the model
                     should be in format [owner]/[model-name]
            folder: the folder to download the model metadata file
        """
        ...
    
    def model_list(self, sort_by=..., search=..., owner=..., page_size=..., page_token=...): # -> list[Model]:
        """ return a list of models!

            Parameters
            ==========
            sort_by: how to sort the result, see valid_model_sort_bys for options
            search: a search term to use (default is empty string)
            owner: username or organization slug to filter the search to
            page_size: the page size to return (default is 20)
            page_token: the page token for pagination
        """
        ...
    
    def model_list_cli(self, sort_by=..., search=..., owner=..., page_size=..., page_token=..., csv_display=...): # -> None:
        """ a wrapper to model_list for the client. Additional parameters
            are described here, see model_list for others.

            Parameters
            ==========
            sort_by: how to sort the result, see valid_model_sort_bys for options
            search: a search term to use (default is empty string)
            owner: username or organization slug to filter the search to
            page_size: the page size to return (default is 20)
            page_token: the page token for pagination
            csv_display: if True, print comma separated values instead of table
        """
        ...
    
    def model_initialize(self, folder): # -> str:
        """ initialize a folder with a model configuration (metadata) file
            Parameters
            ==========
            folder: the folder to initialize the metadata file in
        """
        ...
    
    def model_initialize_cli(self, folder=...): # -> None:
        ...
    
    def model_create_new(self, folder): # -> ModelNewResponse:
        """ create a new model.
             Parameters
            ==========
            folder: the folder to get the metadata file from
        """
        ...
    
    def model_create_new_cli(self, folder=...): # -> None:
        """ client wrapper for creating a new model
             Parameters
            ==========
            folder: the folder to get the metadata file from
        """
        ...
    
    def model_delete(self, model, yes): # -> ModelDeleteResponse:
        """ call to delete a model from the API
             Parameters
            ==========
            model: the string identified of the model
                     should be in format [owner]/[model-name]
            yes: automatic confirmation
        """
        ...
    
    def model_delete_cli(self, model, yes): # -> None:
        """ wrapper for client for model_delete
             Parameters
            ==========
            model: the string identified of the model
                     should be in format [owner]/[model-name]
            yes: automatic confirmation
        """
        ...
    
    def model_update(self, folder): # -> ModelNewResponse:
        """ update a model.
             Parameters
            ==========
            folder: the folder to get the metadata file from
        """
        ...
    
    def model_update_cli(self, folder=...): # -> None:
        """ client wrapper for updating a model
             Parameters
            ==========
            folder: the folder to get the metadata file from
        """
        ...
    
    def model_instance_get(self, model_instance): # -> dict[Any, Any]:
        """ call to get a model instance from the API
             Parameters
            ==========
            model_instance: the string identified of the model instance
                     should be in format [owner]/[model-name]/[framework]/[instance-slug]
        """
        ...
    
    def model_instance_get_cli(self, model_instance, folder=...): # -> None:
        """ wrapper for client for model_instance_get
             Parameters
            ==========
            model_instance: the string identified of the model instance
                     should be in format [owner]/[model-name]/[framework]/[instance-slug]
            folder: the folder to download the model metadata file
        """
        ...
    
    def model_instance_initialize(self, folder): # -> str:
        """ initialize a folder with a model instance configuration (metadata) file
             Parameters
            ==========
            folder: the folder to initialize the metadata file in
        """
        ...
    
    def model_instance_initialize_cli(self, folder): # -> None:
        ...
    
    def model_instance_create(self, folder, quiet=..., dir_mode=...): # -> ModelNewResponse:
        """ create a new model instance.
             Parameters
            ==========
            folder: the folder to get the metadata file from
            quiet: suppress verbose output (default is False)
            dir_mode: what to do with directories: "skip" - ignore; "zip" - compress and upload
        """
        ...
    
    def model_instance_create_cli(self, folder, quiet=..., dir_mode=...): # -> None:
        """ client wrapper for creating a new model instance
             Parameters
            ==========
            folder: the folder to get the metadata file from
            quiet: suppress verbose output (default is False)
            dir_mode: what to do with directories: "skip" - ignore; "zip" - compress and upload
        """
        ...
    
    def model_instance_delete(self, model_instance, yes): # -> ModelDeleteResponse:
        """ call to delete a model instance from the API
             Parameters
            ==========
            model_instance: the string identified of the model instance
                     should be in format [owner]/[model-name]/[framework]/[instance-slug]
            yes: automatic confirmation
        """
        ...
    
    def model_instance_delete_cli(self, model_instance, yes): # -> None:
        """ wrapper for client for model_instance_delete
             Parameters
            ==========
            model_instance: the string identified of the model instance
                     should be in format [owner]/[model-name]/[framework]/[instance-slug]
            yes: automatic confirmation
        """
        ...
    
    def model_instance_files(self, model_instance, page_token=..., page_size=..., csv_display=...): # -> FileList | None:
        """ list all files for the current version of a model instance

            Parameters
            ==========
            model_instance: the string identifier of the model instance
                    should be in format [owner]/[model-name]/[framework]/[instance-slug]
            page_token: token for pagination
            page_size: the number of items per page
            csv_display: if True, print comma separated values instead of table
        """
        ...
    
    def model_instance_files_cli(self, model_instance, page_token=..., page_size=..., csv_display=...): # -> None:
        """ client wrapper for model_instance_files.

            Parameters
            ==========
            model_instance: the string identified of the model instance version
                    should be in format [owner]/[model-name]/[framework]/[instance-slug]
            page_token: token for pagination
            page_size: the number of items per page
            csv_display: if True, print comma separated values instead of table
        """
        ...
    
    def model_instance_update(self, folder): # -> ModelNewResponse:
        """ update a model instance.
             Parameters
            ==========
            folder: the folder to get the metadata file from
        """
        ...
    
    def model_instance_update_cli(self, folder=...): # -> None:
        """ client wrapper for updating a model instance
             Parameters
            ==========
            folder: the folder to get the metadata file from
        """
        ...
    
    def model_instance_version_create(self, model_instance, folder, version_notes=..., quiet=..., dir_mode=...): # -> ModelNewResponse:
        """ create a new model instance version.
             Parameters
            ==========
            model_instance: the string identified of the model instance
                     should be in format [owner]/[model-name]/[framework]/[instance-slug]
            folder: the folder to get the metadata file from
            version_notes: the version notes to record for this new version
            quiet: suppress verbose output (default is False)
            dir_mode: what to do with directories: "skip" - ignore; "zip" - compress and upload
        """
        ...
    
    def model_instance_version_create_cli(self, model_instance, folder, version_notes=..., quiet=..., dir_mode=...): # -> None:
        """ client wrapper for creating a new model instance version
             Parameters
            ==========
            model_instance: the string identified of the model instance
                     should be in format [owner]/[model-name]/[framework]/[instance-slug]
            folder: the folder to get the metadata file from
            version_notes: the version notes to record for this new version
            quiet: suppress verbose output (default is False)
            dir_mode: what to do with directories: "skip" - ignore; "zip" - compress and upload
        """
        ...
    
    def model_instance_version_download(self, model_instance_version, path=..., force=..., quiet=..., untar=...): # -> str:
        """ download all files for a model instance version

            Parameters
            ==========
            model_instance_version: the string identified of the model instance version
                    should be in format [owner]/[model-name]/[framework]/[instance-slug]/[version-number]
            path: the path to download the model instance version to
            force: force the download if the file already exists (default False)
            quiet: suppress verbose output (default is True)
            untar: if True, untar files upon download (default is False)
        """
        ...
    
    def model_instance_version_download_cli(self, model_instance_version, path=..., untar=..., force=..., quiet=...): # -> str:
        """ client wrapper for model_instance_version_download.

            Parameters
            ==========
            model_instance_version: the string identified of the model instance version
                    should be in format [owner]/[model-name]/[framework]/[instance-slug]/[version-number]
            path: the path to download the model instance version to
            force: force the download if the file already exists (default False)
            quiet: suppress verbose output (default is False)
            untar: if True, untar files upon download (default is False)
        """
        ...
    
    def model_instance_version_files(self, model_instance_version, page_token=..., page_size=..., csv_display=...): # -> FileList | None:
        """ list all files for a model instance version

            Parameters
            ==========
            model_instance_version: the string identifier of the model instance version
                    should be in format [owner]/[model-name]/[framework]/[instance-slug]/[version-number]
            page_token: token for pagination
            page_size: the number of items per page
            csv_display: if True, print comma separated values instead of table
        """
        ...
    
    def model_instance_version_files_cli(self, model_instance_version, page_token=..., page_size=..., csv_display=...): # -> None:
        """ client wrapper for model_instance_version_files.

            Parameters
            ==========
            model_instance_version: the string identified of the model instance version
                    should be in format [owner]/[model-name]/[framework]/[instance-slug]/[version-number]
            page_token: token for pagination
            page_size: the number of items per page
            csv_display: if True, print comma separated values instead of table
        """
        ...
    
    def model_instance_version_delete(self, model_instance_version, yes): # -> ModelDeleteResponse:
        """ call to delete a model instance version from the API
             Parameters
            ==========
            model_instance_version: the string identified of the model instance version
                should be in format [owner]/[model-name]/[framework]/[instance-slug]/[version-number]
            yes: automatic confirmation
        """
        ...
    
    def model_instance_version_delete_cli(self, model_instance_version, yes): # -> None:
        """ wrapper for client for model_instance_version_delete
             Parameters
            ==========
            model_instance_version: the string identified of the model instance version
                should be in format [owner]/[model-name]/[framework]/[instance-slug]/[version-number]
            yes: automatic confirmation
        """
        ...
    
    def files_upload_cli(self, local_paths, inbox_path, no_resume, no_compress): # -> None:
        ...
    
    def file_upload_cli(self, local_path, inbox_path, no_compress, upload_context): # -> tuple[UploadFile | None, Any]:
        ...
    
    def print_obj(self, obj, indent=...): # -> None:
        ...
    
    def download_needed(self, response, outfile, quiet=...): # -> bool:
        """ determine if a download is needed based on timestamp. Return True
            if needed (remote is newer) or False if local is newest.
             Parameters
            ==========
            response: the response from the API
            outfile: the output file to write to
            quiet: suppress verbose output (default is True)
        """
        ...
    
    def print_table(self, items, fields): # -> None:
        """ print a table of items, for a set of fields defined

            Parameters
            ==========
            items: a list of items to print
            fields: a list of fields to select from items
        """
        ...
    
    def print_csv(self, items, fields): # -> None:
        """ print a set of fields in a set of items using a csv.writer

            Parameters
            ==========
            items: a list of items to print
            fields: a list of fields to select from items
        """
        ...
    
    def string(self, item): # -> unicode:
        ...
    
    def get_or_fail(self, data, key):
        ...
    
    def get_or_default(self, data, key, default):
        ...
    
    def set_if_present(self, data, key, output, output_key): # -> None:
        ...
    
    def get_dataset_metadata_file(self, folder): # -> str:
        ...
    
    def get_model_metadata_file(self, folder): # -> str:
        ...
    
    def get_model_instance_metadata_file(self, folder): # -> str:
        ...
    
    def process_response(self, result): # -> dict[Any, Any]:
        """ process a response from the API. We check the API version against
            the client's to see if it's old, and give them a warning (once)

            Parameters
            ==========
            result: the result from the API
        """
        ...
    
    def is_up_to_date(self, server_version): # -> bool:
        """ determine if a client (on the local user's machine) is up to date
            with the version provided on the server. Return a boolean with True
            or False
             Parameters
            ==========
            server_version: the server version string to compare to the host
        """
        ...
    
    def upload_files(self, request, resources, folder, blob_type, upload_context, quiet=..., dir_mode=...): # -> None:
        """ upload files in a folder
             Parameters
            ==========
            request: the prepared request
            resources: the files to upload
            folder: the folder to upload from
            blob_type (ApiBlobType): To which entity the file/blob refers
            upload_context (ResumableUploadContext): Context for resumable uploads
            quiet: suppress verbose output (default is False)
        """
        ...
    
    def process_column(self, column): # -> DatasetColumn:
        """ process a column, check for the type, and return the processed
            column
             Parameters
            ==========
            column: a list of values in a column to be processed
        """
        ...
    
    def upload_complete(self, path, url, quiet, resume=...): # -> int:
        """ function to complete an upload to retrieve a path from a url
             Parameters
            ==========
            path: the path for the upload that is read in
            url: the url to send the POST to
            quiet: suppress verbose output (default is False)
        """
        ...
    
    def validate_dataset_string(self, dataset): # -> None:
        """ determine if a dataset string is valid, meaning it is in the format
            of {username}/{dataset-slug} or {username}/{dataset-slug}/{version-number}.
             Parameters
            ==========
            dataset: the dataset name to validate
        """
        ...
    
    def split_dataset_string(self, dataset): # -> tuple[Any, Any, Any] | tuple[Any, Any, None] | tuple[Any | None, Any, None]:
        """ split a dataset string into owner_slug, dataset_slug,
            and optional version_number
             Parameters
            ==========
            dataset: the dataset name to split
        """
        ...
    
    def validate_model_string(self, model): # -> None:
        """ determine if a model string is valid, meaning it is in the format
            of {owner}/{model-slug}.
             Parameters
            ==========
            model: the model name to validate
        """
        ...
    
    def split_model_string(self, model): # -> tuple[Any, Any] | tuple[Any | None, Any]:
        """ split a model string into owner_slug, model_slug
             Parameters
            ==========
            model: the model name to split
        """
        ...
    
    def validate_model_instance_string(self, model_instance): # -> None:
        """ determine if a model instance string is valid, meaning it is in the format
            of {owner}/{model-slug}/{framework}/{instance-slug}.
             Parameters
            ==========
            model_instance: the model instance name to validate
        """
        ...
    
    def split_model_instance_string(self, model_instance): # -> tuple[Any, Any, Any, Any]:
        """ split a model instance string into owner_slug, model_slug, 
            framework, instance_slug
             Parameters
            ==========
            model_instance: the model instance name to validate
        """
        ...
    
    def validate_model_instance_version_string(self, model_instance_version): # -> None:
        """ determine if a model instance version string is valid, meaning it is in the format
            of {owner}/{model-slug}/{framework}/{instance-slug}/{version-number}.
             Parameters
            ==========
            model_instance_version: the model instance version name to validate
        """
        ...
    
    def validate_kernel_string(self, kernel): # -> None:
        """ determine if a kernel string is valid, meaning it is in the format
            of {username}/{kernel-slug}.
             Parameters
            ==========
            kernel: the kernel name to validate
        """
        ...
    
    def validate_model_string(self, model): # -> None:
        """ determine if a model string is valid, meaning it is in the format
            of {username}/{model-slug}/{framework}/{variation-slug}/{version-number}.
             Parameters
            ==========
            model: the model name to validate
        """
        ...
    
    def validate_resources(self, folder, resources): # -> None:
        """ validate resources is a wrapper to validate the existence of files
            and that there are no duplicates for a folder and set of resources.

            Parameters
            ==========
            folder: the folder to validate
            resources: one or more resources to validate within the folder
        """
        ...
    
    def validate_files_exist(self, folder, resources): # -> None:
        """ ensure that one or more resource files exist in a folder

            Parameters
            ==========
            folder: the folder to validate
            resources: one or more resources to validate within the folder
        """
        ...
    
    def validate_no_duplicate_paths(self, resources): # -> None:
        """ ensure that the user has not provided duplicate paths in
            a list of resources.

            Parameters
            ==========
            resources: one or more resources to validate not duplicated
        """
        ...
    
    def convert_to_dataset_file_metadata(self, file_data, path): # -> dict[str, Any]:
        """ convert a set of file_data to a metadata file at path

            Parameters
            ==========
            file_data: a dictionary of file data to write to file
            path: the path to write the metadata to
        """
        ...
    
    def validate_date(self, date): # -> None:
        ...
    
    def sanitize_markdown(self, markdown): # -> str:
        ...
    
    def confirmation(self): # -> bool:
        ...
    


class TqdmBufferedReader(io.BufferedReader):
    def __init__(self, raw, progress_bar) -> None:
        """ helper class to implement an io.BufferedReader
             Parameters
            ==========
            raw: bytes data to pass to the buffered reader
            progress_bar: a progress bar to initialize the reader
        """
        ...
    
    def read(self, *args, **kwargs): # -> bytes:
        """ read the buffer, passing named and non named arguments to the
            io.BufferedReader function.
        """
        ...
    
    def increment(self, length): # -> None:
        """ increment the reader by some length

            Parameters
            ==========
            length: bytes to increment the reader by
        """
        ...
    


class FileList:
    def __init__(self, init_dict) -> None:
        ...
    
    def __repr__(self): # -> Literal['']:
        ...
    


